#+TITLE: Logic Programming Silent Hill 3
#+LAYOUT: post
#+DATE:   2018-01-11 10:48:00 -0800
#+TAGS: clojure logic silent-hill horror
#+image: /assets/article_images/sh_logic/puzzle_1_small.png
#+image2: /assets/article_images/sh_logic/puzzle_1_small.png
#+liquid: enabled

* Convergent Circles
  
Every now and then you find an interesting overlap in diverse interests and it seems worth taking note of. 

** Logic Programming
   
I've been very interested in logic programming using MiniKannren after watching the presentation [[https://www.youtube.com/watch?v=OyfBQmvr2Hc][The Most Beautiful Program Ever Written]]. Logic programming requires a completely different mind-set going in. The functional approach at its most basic level consists of describing functions with which you can build up an answer. Logic program entails beginning with a set of unbound variables, which equate to any possible value, then constraing their possible values down until you have an answer.

** Silent Hill

Silent Hill is a video game franchise published by Konami. While there is a lot to say about use and abuse of the license over time it is widely agreed that the original trilogy are masterpieces of the horror genre. Instead of going for cheap jump scares they make the player confront nightmarish horrors which are truly terrifying and confounding to comprehend.

#+BEGIN_QUOTE
A small, beautiful little team of passionate rejects and failures got their chance to make a spooky game followed up by arguably the most brilliant and beautifully crafted survival horror game ever made.

    -- [[https://www.youtube.com/watch?v=hycpdjjcnRE][NakeyJakey]]
#+END_QUOTE

Silent Hill games are built largely on two game mechanics. Combatting monsters and solving puzzles. At the start of every game the player must choose difficulty settings for these two components independently of each other. The puzzles in the game actually change their text based on how much of a mental challenge you want.

I think this incorporation of puzzles actually helps enhance the horror you experience quite well. You are forced to engage the game with the very rational and logical parts of your brain. The same parts of your brain which fail to understand the horrific logic put forward by a nightmarish hellscape.

* Programming Our Way Into The Hospital
  
Now to bring these two concepts together. In Silent Hill 3 after arriving at the town of Silent Hill proper you are left to once again explore the Brookhaven Hospital you explored previously in Silent Hill 2. Things have changed just enough from your previous visit to leave you uncomfortable.

After making your way to the second floor and battling with sexy-zombie-bobble-head-nurses you are confronted with a locked door with a nine digit key pad and a riddle with its key combination.

#+BEGIN_QUOTE
The first is larger than the second;
the second twice the third;
the third smaller than the fourth;
the fourth is half the first.

Four of the numbers
are not repeated
Three are not in the top row
Two are not in the right row
One of the numbers is the final key
#+END_QUOTE

Deciphering this riddle requires following logical constraints and making relationships between the digits -- a problem perfectly in the domain of logic based programming! So without further ado, let's code!

* Setting Things Up

First we make a new Clojure app with leiningen with:

#+BEGIN_SRC bash
  lein new app sh-logic
#+END_SRC

Next, we need to include the core.logic library in our Clojure project. So we change our ~project.clj~ file to have the following dependencies:

#+BEGIN_SRC clojure
  :dependencies [[org.clojure/clojure "1.9.0"]
                 [org.clojure/core.logic "0.8.11"]]
#+END_SRC

Install our dependencies:

#+BEGIN_SRC bash
  lein deps
#+END_SRC

And finally we get our ~src/sh_logic/core.clj~ ready to write logic code by using the ~core.logic~ and requiring the ~core.logic.fd~ libraries:

#+BEGIN_SRC clojure
  (ns sh-logic.core
    (:gen-class)
    (:refer-clojure :exclude [==])
    (:use [clojure.core.logic])
    (:require [clojure.core.logic.fd :as fd]))
#+END_SRC

* Getting Logical
  
What we're actually after here is a function we can call which will return the answer to our puzzle. It should ask the core.logic solver to find all values for q which could be our answer. So let's make that:

#+BEGIN_SRC clojure
  (defn solve-puzzle []
    (run* [q]

      ))
#+END_SRC

All of our following code will go inside this run* statement.

** Defining q

At this point q is an unbound variable which could be anything. That's not very helpful. So let's tell core.logic what q should be, a list of four variables holding our answer. We introduce the new variables representing each digit with ~fresh~. We then unify the list of these digits with q using ~==~.

#+BEGIN_SRC clojure
  (fresh [a b c d]
    (== q [a b c d]))
#+END_SRC

At this point running our program gives us the following output:

#+BEGIN_SRC clojure
  ([_0 _1 _2 _3])
#+END_SRC

Roughly translated this means our answer is a list of four variables which could be anything.

** Limiting to a Finite Domain

Now we know that our unbound variables can't be literally any value. They each have to be one of the values 1 through 9. We can apply this constraint to our answers with the ~fd/in~ function. This lets us define a ~fd/domain~, which is a list of numbers that are possible values. We can then apply this constratint over our list of numbers with the ~everyg~ function which lets us apply this constraint over a list of variables.

#+BEGIN_SRC clojure
  (everyg #(fd/in % (fd/domain 1 2 3 4 5 6 7 8 9)) [a b c d])
#+END_SRC

Now the ouput of our function looks like this:

#+BEGIN_SRC clojure
  ([1 1 1 1] [2 1 1 1] [1 2 1 1] [3 1 1 1] [1 1 2 1] [2 2 1 1] [1 1 1 2] [1 3 1 1] [4 1 1 1] [2 1 2 1] [1 2 2 1] [1 1 1 3] ...)
#+END_SRC

This is a list of every possible combination of four digit numbers. Very interesting!

** The first is larger than the second;

Now we can start describing relationships amongst our variables. ~core.logic.fd~ has a few different operator which map directly to the relationships of the riddle. The following is almost a direct trasncription of this line into code:

#+BEGIN_SRC clojure
  (fd/> a b)
#+END_SRC

Now our output is as follows:

#+BEGIN_SRC clojure
  ([2 1 1 1] [3 1 1 1] [2 1 2 1] [2 1 1 2] [4 1 1 1] [3 2 1 1] ...)
#+END_SRC

Notice that any value where the first digit is less than or equal to the second digit is gone.  We're finally getting somewhere.

** the second twice the third;
   
We can once again use a ~core.logic.fd~ constraint to directly transcribe this line:

#+BEGIN_SRC clojure
  (fd/* c 2 b)
#+END_SRC

Our output is now pruned to satisfying these constraints:

#+BEGIN_SRC clojure
  ([3 2 1 1] [4 2 1 1] [3 2 1 2] [3 2 1 3] [5 2 1 1] [3 2 1 4] ...)
#+END_SRC

** the third smaller than the fourth; the fourth is half the first.

Now it's just the same gag for these next two lines, so let's get them in one go.

#+BEGIN_SRC clojure
  (fd/< c d)
  (fd/* d 2 a)
#+END_SRC

This leads us to the following ouput:

#+BEGIN_SRC clojure
  ([4 2 1 2] [6 2 1 3] [8 2 1 4] [6 4 2 3] [8 4 2 4] [8 6 3 4])
#+END_SRC

Aha! We're getting close.

** Four of the numbers are not repeated
   
This calls for a new type of constraint -- ~fd/distinct~. This ensures that no two variables have the same value.

On a side note this constraint is the basis for an absurdly terse Sudoku solver where you simply split the puzzle into rows, columns, and squares then ensure they are all distinct.

For now, let's constrain our digits.

#+BEGIN_SRC clojure
  (fd/distinct [a b c d])
#+END_SRC

Which leaves us dangerously close to a solution:

#+BEGIN_SRC clojure
  ([6 2 1 3] [8 2 1 4] [6 4 2 3] [8 6 3 4])
#+END_SRC

** Three are not in the top row
   
This line is particulary tricky in wording and difficult to implement. The top row are the values ~1 2 3~. This means that one number may or may not be 3 or less. It would be quite simple to at this point just write a predicate function and filter over the output of our logic program. I want to however solve this puzzle entirely using logic.

My current solution is as follows:
1. Create four new logic variables
2. Attach each to one of the original four variables
3. Ensure that the first is less than the other three, the second less than the next two, and the third less than the fourth
4. Ensure that the second of these is greater than 3

That is, sort the numbers then make sure that the three largest are greater than three. In code this is:

#+BEGIN_SRC clojure
  (fresh [l1 l2 l3 l4]
    (everyg #(membero % q) [l1 l2 l3 l4])
    (fd/distinct [l1 l2 l3 l4])
    (fd/< l1 l2)
    (fd/< l1 l3)
    (fd/< l1 l4)
    (fd/< l2 l3)
    (fd/< l2 l4)
    (fd/< l3 l4)
    (fd/> l2 3))
#+END_SRC

This finally gives us a single solution:

#+BEGIN_SRC clojure
  ([8 6 3 4])
#+END_SRC

Entering this code opens the door and let's us continue on.

** All Together Now

The complete code is available at [[https://github.com/EnnuiOcclusion/sh-logic]].

* Next Steps

I like the creativity of that last solution, but I'd like something more expressive. I'd like to both generalize lvar sorting into a function called ~sorto~ and also come up with a constraint which roughly translates to "ensure that only one member of q is in the set [1 2 3]". Any help on this is appreciated. I'll update if I find either of these.
