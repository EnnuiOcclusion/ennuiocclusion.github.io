#+TITLE: Beginner's Guide to Atoms in Clojure
#+LAYOUT: post
#+DATE:   2018-01-03 22:42:00 -0800
#+TAGS: lisp clojure
#+liquid: enabled

State is the data which exists outside the scope of a single function and is antithetical to the entire being of functional programming. State management is a tricky topic and mutable state is probably the most common source of run-time bugs in programs. Some of the most difficult tasks in computing are centered around the expert manipulation of large state-machines like OpenGL. This is why Nvidia has such a thriving business of Game-Readyâ„¢ drivers.

Clojure's answer to managing mutable state and remaining a functional language is just to remove mutability entirely. Everything is immutable! All variables will always return the same value.

How is anything ever done if nothing ever changes? How does a user interact with your program and change the variables controlling what happens?

Software Transactional Memory! We use functions called atoms as little data-stores which deal with that god-awful state for us.

We define atoms like so:

#+BEGIN_SRC clojure :exports both
  (def my-memory-hole (atom {:text "Hello there!"}))
#+END_SRC

#+RESULTS:
: #'user/my-memory-hole

We can then get the contents of that atom by calling the deref function. We are going to do this so often that the Clojure language has the reader macro of ~@~ assigned to calling this function.

#+BEGIN_SRC clojure :exports both
  @my-memory-hole
#+END_SRC

#+RESULTS:
: | :text | Hello there! |

If we want to modify the atom we can either wipe the whole thing out with reset:

#+BEGIN_SRC clojure :exports both
  (reset! my-memory-hole {:text "Hey sexy"})
#+END_SRC

#+RESULTS:
: | :text | Hey sexy |

Or we can modify the atom with a call to swap and pass in a function which takes in the previous value of the atom as its only argument:

#+BEGIN_SRC clojure :exports both
  (swap! my-memory-hole #(assoc % :text (str (:text %) " friendo!")))
#+END_SRC

#+RESULTS:
: | :text | Hey sexy friendo! |

And that's pretty much all you need to know to get going with atoms and mutable state. What's really amazing is how little you actually need to directly access atoms. For a game-engine environment the atom only needs to be read once at the start of every frame and written once at the end. All other manipulation of data can be handled through function threading, meaning you've removed state from all your actual business logic.

More on these threading macros to come!

->

